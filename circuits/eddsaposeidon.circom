/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.5;

// The templates and functions of this file only work for prime field bn128 (21888242871839275222246405745257275088548364400416034343698204186575808495617)

include "comparators.circom";
include "poseidon.circom";
include "bitify.circom";
include "escalarmul/escalarmulany.circom";
include "escalarmul/escalarmulfix.circom";
include "buses.circom";

/*

*** EdDSAPoseidonVerifier(): template that implements the EdDSA verification protocol based on poseidon hash. The circuit receives the message that we want to verify and the public and private keys (that are points of a curve in Edwards representation) and checks if the message is correct.
        - Inputs: msg -> field value
                  enabled -> bit indicating if the verification is enabled or not
                             requires tag binary
                  Ax -> x coodinate of the curve point A that is in Edwards representation
                  Ay -> y coodinate of the curve point A that is in Edwards representation
                  S -> value of the subgroup generated by the prime 2736030358979909402780800718157159386076813972158567259200215660948447373041
                  R8x -> x coodinate of the curve point R8 that is in Edwards representation
                  R8y -> y coodinate of the curve point R8 that is in Edwards representation
        - Outputs: None
*/


template EdDSAPoseidonVerifier() {
    signal input {binary} enabled;
    Point input {babyedwards} A;

    signal input S;
    Point input {babyedwards} R8;

    signal input M;

    var i;

// Ensure S<Subgroup Order

    component snum2bits = Num2Bits(253);
    snum2bits.in <== S;

    component  compConstant = CompConstant(2736030358979909402780800718157159386076813972158567259200215660948447373040);

    for (i=0; i<253; i++) {
        snum2bits.out[i] ==> compConstant.in[i];
    }
    
    signal {binary} aux_0 <== 0;
    compConstant.in[253] <== aux_0;
    compConstant.out*enabled === 0;

// Calculate the h = H(R,A, msg)

    component hash = Poseidon(5);

    hash.inputs[0] <== R8.x;
    hash.inputs[1] <== R8.y;
    hash.inputs[2] <== A.x;
    hash.inputs[3] <== A.y;
    hash.inputs[4] <== M;

    component h2bits = Num2Bits_strict();
    h2bits.in <== hash.out;

// Calculate second part of the right side:  right2 = h*8*A

    // Multiply by 8 by adding it 3 times.  This also ensure that the result is in
    // the subgroup.
    component dbl1 = BabyDbl();
    dbl1.pin <== A;
    component dbl2 = BabyDbl();
    dbl2.pin <== dbl1.pout;
    component dbl3 = BabyDbl();
    dbl3.pin <== dbl2.pout;

    // We check that A is not zero.
    component isZero = IsZero();
    isZero.in <== dbl3.pin.x;
    isZero.out*enabled === 0;

    component mulAny = EscalarMulAny(254);
    mulAny.e <== h2bits.out;
    mulAny.pin <== dbl3.pout;


// Compute the right side: right =  R8 + right2

    component addRight = BabyAdd();
    addRight.pin1 <== R8;
    addRight.pin2 <== mulAny.pout;

// Calculate left side of equation left = S*B8

    var BASE8[2] = [
        5299619240641551281634865583518297030282874472190772894086521144482721001553,
        16950150798460657717958625567821834550301663161624707787222815936182638968203
    ];
    component mulFix = EscalarMulFix(253, BASE8);
    mulFix.e <== snum2bits.out;

// Do the comparation left == right if enabled;

    component eqCheckX = ForceEqualIfEnabled();
    eqCheckX.enabled <== enabled;
    eqCheckX.in[0] <== mulFix.pout.x;
    eqCheckX.in[1] <== addRight.pout.x;

    component eqCheckY = ForceEqualIfEnabled();
    eqCheckY.enabled <== enabled;
    eqCheckY.in[0] <== mulFix.pout.y;
    eqCheckY.in[1] <== addRight.pout.y;
}
